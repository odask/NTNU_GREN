{"ast":null,"code":"var _jsxFileName = \"/Users/odaskaug/Documents/ntnu_gren/src/components/Treemap.js\",\n    _s = $RefreshSig$();\n\nimport { useRef, useEffect } from 'react';\nimport * as d3 from 'd3';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function Treemap({\n  data,\n  width,\n  height\n}) {\n  _s();\n\n  const svgRef = useRef(null);\n  const legendRef = useRef(null);\n\n  function renderTreemap() {\n    const svg = d3.select(svgRef.current);\n    svg.selectAll('g').remove();\n    const legendContainer = d3.select(legendRef.current);\n    legendContainer.selectAll('g').remove();\n    svg.attr('width', width).attr('height', height); // create root node\n\n    const root = d3.hierarchy(data).sum(d => d.value).sort((a, b) => b.value - a.value); // create treemap layout\n\n    const treemapRoot = d3.treemap().size([width, height]).padding(1)(root); // create 'g' element nodes based on data\n\n    const nodes = svg.selectAll('g').data(treemapRoot.leaves()).join('g').attr('transform', d => `translate(${d.x0},${d.y0})`); // create color scheme and fader\n\n    const fader = color => d3.interpolateRgb(color, '#fff')(0.3);\n\n    const colorScale = d3.scaleOrdinal(d3.schemeCategory10.map(fader)); // add treemap rects\n\n    nodes.append('rect').attr('width', d => d.x1 - d.x0).attr('height', d => d.y1 - d.y0).attr('fill', d => colorScale(d.data.category));\n    const fontSize = 18; // add text to rects\n\n    nodes.append('text').text(d => `${d.data.name} ${d.data.value}`).attr('data-width', d => d.x1 - d.x0).attr('font-size', `${fontSize}px`).attr('x', 3).attr('y', fontSize).call(wrapText);\n\n    function wrapText(selection) {\n      selection.each(function () {\n        const node = d3.select(this);\n        const rectWidth = +node.attr('data-width');\n        let word;\n        const words = node.text().split(' ').reverse();\n        let line = [];\n        let lineNumber = 0;\n        const x = node.attr('x');\n        const y = node.attr('y');\n        let tspan = node.text('').append('tspan').attr('x', x).attr('y', y);\n\n        while (words.length > 1) {\n          word = words.pop();\n          line.push(word);\n          tspan.text(line.join(' '));\n          const tspanLength = tspan.node().getComputedTextLength();\n\n          if (tspanLength > rectWidth && line.length !== 1) {\n            line.pop();\n            tspan.text(line.join(' '));\n            line = [word];\n            tspan = addTspan(word);\n          }\n        }\n\n        addTspan(words.pop());\n\n        function addTspan(text) {\n          lineNumber += 1;\n          return node.append('tspan').attr('x', x).attr('y', y).attr('dy', `${lineNumber * fontSize}px`).text(text).style(\"fill\", \"white\");\n        }\n      });\n    } // pull out hierarchy categories\n\n\n    let categories = root.leaves().map(node => node.data.category);\n    categories = categories.filter((category, index, self) => self.indexOf(category) === index);\n    legendContainer.attr('width', width).attr('height', height / 4); // create 'g' elements based on categories\n\n    const legend = legendContainer.selectAll('g').data(categories).join('g'); // create 'rects' for each category\n\n    legend.append('rect').attr('width', fontSize).attr('height', fontSize).attr('x', fontSize).attr('y', (_, i) => fontSize * 2 * i).attr('fill', d => colorScale(d)); // add text to each category key\n\n    legend.append('text').attr('transform', `translate(0, ${fontSize})`).attr('x', fontSize * 3).attr('y', (_, i) => fontSize * 2 * i).style('font-size', fontSize).text(d => d);\n  }\n\n  useEffect(() => {\n    renderTreemap();\n  }, [data]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: /*#__PURE__*/_jsxDEV(\"svg\", {\n      ref: svgRef\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 131,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 130,\n    columnNumber: 5\n  }, this);\n}\n\n_s(Treemap, \"BOLF3j+ndozU6DZjUBtRtVpNu2E=\");\n\n_c = Treemap;\n\nvar _c;\n\n$RefreshReg$(_c, \"Treemap\");","map":{"version":3,"sources":["/Users/odaskaug/Documents/ntnu_gren/src/components/Treemap.js"],"names":["useRef","useEffect","d3","Treemap","data","width","height","svgRef","legendRef","renderTreemap","svg","select","current","selectAll","remove","legendContainer","attr","root","hierarchy","sum","d","value","sort","a","b","treemapRoot","treemap","size","padding","nodes","leaves","join","x0","y0","fader","color","interpolateRgb","colorScale","scaleOrdinal","schemeCategory10","map","append","x1","y1","category","fontSize","text","name","call","wrapText","selection","each","node","rectWidth","word","words","split","reverse","line","lineNumber","x","y","tspan","length","pop","push","tspanLength","getComputedTextLength","addTspan","style","categories","filter","index","self","indexOf","legend","_","i"],"mappings":"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","sourcesContent":["\nimport { useRef, useEffect } from 'react';\nimport * as d3 from 'd3';\n\nexport default function Treemap({ data, width, height }) {\n  const svgRef = useRef(null);\n  const legendRef = useRef(null);\n\n  function renderTreemap() {\n    const svg = d3.select(svgRef.current);\n    svg.selectAll('g').remove();\n\n    const legendContainer = d3.select(legendRef.current);\n    legendContainer.selectAll('g').remove();\n\n    svg.attr('width', width).attr('height', height);\n\n    // create root node\n    const root = d3\n      .hierarchy(data)\n      .sum((d) => d.value)\n      .sort((a, b) => b.value - a.value);\n\n    // create treemap layout\n    const treemapRoot = d3.treemap().size([width, height]).padding(1)(root);\n\n    // create 'g' element nodes based on data\n    const nodes = svg\n      .selectAll('g')\n      .data(treemapRoot.leaves())\n      .join('g')\n      .attr('transform', (d) => `translate(${d.x0},${d.y0})`);\n\n    // create color scheme and fader\n    const fader = (color) => d3.interpolateRgb(color, '#fff')(0.3);\n    const colorScale = d3.scaleOrdinal(d3.schemeCategory10.map(fader));\n\n    // add treemap rects\n    nodes\n      .append('rect')\n      .attr('width', (d) => d.x1 - d.x0)\n      .attr('height', (d) => d.y1 - d.y0)\n      .attr('fill', (d) => colorScale(d.data.category));\n\n    const fontSize = 18;\n\n    // add text to rects\n    nodes\n      .append('text')\n      .text((d) => `${d.data.name} ${d.data.value}`)\n      .attr('data-width', (d) => d.x1 - d.x0)\n      .attr('font-size', `${fontSize}px`)\n      .attr('x', 3)\n      .attr('y', fontSize)\n      .call(wrapText);\n\n    function wrapText(selection) {\n      selection.each(function () {\n        const node = d3.select(this);\n        const rectWidth = +node.attr('data-width');\n        let word;\n        const words = node.text().split(' ').reverse();\n        let line = [];\n        let lineNumber = 0;\n        const x = node.attr('x');\n        const y = node.attr('y');\n        let tspan = node.text('').append('tspan').attr('x', x).attr('y', y);\n        while (words.length > 1) {\n          word = words.pop();\n          line.push(word);\n          tspan.text(line.join(' '));\n          const tspanLength = tspan.node().getComputedTextLength();\n          if (tspanLength > rectWidth && line.length !== 1) {\n            line.pop();\n            tspan.text(line.join(' '));\n            line = [word];\n            tspan = addTspan(word);\n          }\n        }\n        addTspan(words.pop());\n\n        function addTspan(text) {\n          lineNumber += 1;\n          return node\n            .append('tspan')\n            .attr('x', x)\n            .attr('y', y)\n            .attr('dy', `${lineNumber * fontSize}px`)\n            .text(text)\n            .style(\"fill\", \"white\");\n        }\n      });\n    }\n\n    // pull out hierarchy categories\n    let categories = root.leaves().map((node) => node.data.category);\n    categories = categories.filter(\n      (category, index, self) => self.indexOf(category) === index,\n    );\n\n    legendContainer.attr('width', width).attr('height', height / 4);\n\n    // create 'g' elements based on categories\n    const legend = legendContainer.selectAll('g').data(categories).join('g');\n\n    // create 'rects' for each category\n    legend\n      .append('rect')\n      .attr('width', fontSize)\n      .attr('height', fontSize)\n      .attr('x', fontSize)\n      .attr('y', (_, i) => fontSize * 2 * i)\n      .attr('fill', (d) => colorScale(d));\n\n    // add text to each category key\n    legend\n      .append('text')\n      .attr('transform', `translate(0, ${fontSize})`)\n      .attr('x', fontSize * 3)\n      .attr('y', (_, i) => fontSize * 2 * i)\n      .style('font-size', fontSize)\n      .text((d) => d);\n  }\n\n  useEffect(() => {\n    renderTreemap();\n  }, [data]);\n\n  return (\n    <div>\n      <svg ref={svgRef} />\n    </div>\n  );\n}"]},"metadata":{},"sourceType":"module"}